#include <stdio.h>
#include <string.h>
#include "esp_log.h"
#include "nvs_flash.h"
#include "nimble/nimble_port.h"
#include "nimble/nimble_port_freertos.h"
#include "host/ble_hs.h"
#include "host/ble_gap.h"
#include "host/ble_hs_adv.h"
#include "services/gap/ble_svc_gap.h"
#include "host/ble_sm.h"
#include <stdbool.h>
#if 1
static const char *TAG = "NIMBLE_MOUSE";
#define MAX_DEVICES 10
static ble_addr_t connected_devices[MAX_DEVICES];
static int device_count = 0;

static bool is_device_connected(const ble_addr_t *addr)
{
    for (int i = 0; i < device_count; i++)
    {
        if (memcmp(&connected_devices[i], addr, sizeof(ble_addr_t)) == 0)
        {
            return true;
        }
    }
    return false;
}

static void add_device(const ble_addr_t *addr)
{
    if (device_count < MAX_DEVICES)
    {
        memcpy(&connected_devices[device_count], addr, sizeof(ble_addr_t));
        device_count++;
    }
}

static int ble_gap_event(struct ble_gap_event *event, void *arg)
{
    switch (event->type)
    {
    case BLE_GAP_EVENT_DISC:
    {

        const uint8_t *adv_data = event->disc.data;
        uint8_t adv_len = event->disc.length_data;

        struct ble_hs_adv_fields fields;
        ble_hs_adv_parse_fields(&fields, adv_data, adv_len);

        ble_uuid16_t uuid16 = BLE_UUID16_INIT(0x1812);
        const ble_uuid_t *uuid = &uuid16.u;
        if (fields.num_uuids16 > 0 && ble_uuid_cmp(&fields.uuids16[0].u, uuid) == 0)
        {
            if (!is_device_connected(&event->disc.addr))
            {
                char addr_str[18];
                sprintf(addr_str, "%02X:%02X:%02X:%02X:%02X:%02X",
                        event->disc.addr.val[5], event->disc.addr.val[4],
                        event->disc.addr.val[3], event->disc.addr.val[2],
                        event->disc.addr.val[1], event->disc.addr.val[0]);
                ESP_LOGI(TAG, "Found HID device: %s", addr_str);
                ESP_LOGI(TAG, "Connecting...");
                ble_gap_connect(BLE_OWN_ADDR_PUBLIC, &event->disc.addr, 30000, NULL, ble_gap_event, NULL);
                add_device(&event->disc.addr);
            }
        }
        break;
    }
    case BLE_GAP_EVENT_CONNECT:
        if (event->connect.status == 0)
        {
            ESP_LOGI(TAG, "Connected to device");
        }
        else
        {
            ESP_LOGE(TAG, "Connection failed, status: %d", event->connect.status);
        }
        break;

    case BLE_GAP_EVENT_DISCONNECT:
        ESP_LOGI(TAG, "Disconnected from device");
        break;

    default:
        break;
    }
    return 0;
}

static void ble_scan(void)
{
    struct ble_gap_disc_params disc_params = {
        .itvl = 0x0010,
        .window = 0x0010,
        .filter_policy = 0,
        .limited = 0,
        .passive = 0,
        .filter_duplicates = 0};
    ESP_LOGI(TAG, "Starting scan...");
    ble_gap_disc(BLE_OWN_ADDR_PUBLIC, BLE_HS_FOREVER, &disc_params, ble_gap_event, NULL);
}

void ble_app_on_sync(void)
{
    ble_svc_gap_device_name_set("ESP32_S3_Mouse_Host");
    ble_scan();
}

void nimble_port_task(void *arg)
{
    nimble_port_run();
}

void bt_start(void)
{
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND)
    {
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);

    nimble_port_init();
    ble_hs_cfg.sync_cb = ble_app_on_sync;
    xTaskCreate(nimble_port_task, "nimble_task", 4096, NULL, 5, NULL);
}

#else
static const char *TAG = "NIMBLE_MOUSE";
static void ble_scan();

int ble_gap_event(struct ble_gap_event *event, void *arg)
{
    switch (event->type)
    {
    case BLE_GAP_EVENT_CONNECT:
        if (event->connect.status == 0)
        {
            printf("Connection established\n");
        }
        else
        {
            printf("Connection failed; restarting scan\n");
            ble_scan();
        }
        break;

    case BLE_GAP_EVENT_DISCONNECT:
        printf("Disconnected; restarting scan\n");
        ble_scan();
        break;

    case BLE_GAP_EVENT_PASSKEY_ACTION:
        if (event->passkey.params.action == BLE_SM_IOACT_DISP)
        {
            printf("Passkey: %06lu\n", event->passkey.params.numcmp);
        }
        break;

    default:
        break;
    }
    return 0;
}
// 配对回调函数
static int ble_sm_event(struct ble_gap_event *event, void *arg)
{
    switch (event->type)
    {
    case BLE_GAP_EVENT_PASSKEY_ACTION:
        ESP_LOGI(TAG, "Passkey action event");
        if (event->passkey.params.action == BLE_SM_IOACT_NUMCMP)
        {
            ble_sm_inject_io(event->passkey.params.numcmp);
        }
        break;
    default:
        break;
    }
    return 0;
}

// GAP 事件回调函数
static int ble_gap_event(struct ble_gap_event *event, void *arg)
{
    switch (event->type)
    {
    case BLE_GAP_EVENT_DISC:
    {
        char addr_str[18];
        sprintf(addr_str, "%02X:%02X:%02X:%02X:%02X:%02X",
                event->disc.addr.val[5], event->disc.addr.val[4],
                event->disc.addr.val[3], event->disc.addr.val[2],
                event->disc.addr.val[1], event->disc.addr.val[0]);
        ESP_LOGI(TAG, "Device found: %s", addr_str);

        const uint8_t *adv_data = event->disc.data;
        uint8_t adv_len = event->disc.length_data;

        struct ble_hs_adv_fields fields;
        ble_hs_adv_parse_fields(&fields, adv_data, adv_len);

        ble_uuid16_t uuid16 = BLE_UUID16_INIT(0x1812); // HID Service UUID
        const ble_uuid_t *uuid = &uuid16.u;

        if (fields.num_uuids16 > 0 && ble_uuid_cmp(&fields.uuids16[0].u, uuid) == 0)
        {
            ESP_LOGI(TAG, "Found HID device, connecting...");

            int addr_type = event->disc.addr.type == BLE_ADDR_PUBLIC ? BLE_ADDR_PUBLIC : BLE_ADDR_RANDOM;
            int rc = ble_gap_connect(addr_type, &event->disc.addr, 30000, NULL, ble_gap_event, NULL);

            if (rc != 0)
            {
                ESP_LOGE(TAG, "Failed to connect, error code: %d", rc);
            }
        }
        break;
    }

    case BLE_GAP_EVENT_CONNECT:
        if (event->connect.status == 0)
        {
            ESP_LOGI(TAG, "Connected to device");
        }
        else
        {
            ESP_LOGE(TAG, "Connection failed, reason: %d", event->connect.status);
            ble_scan(); // Restart scanning
        }
        break;

    case BLE_GAP_EVENT_DISCONNECT:
        ESP_LOGI(TAG, "Disconnected from device, reason: %d", event->disconnect.reason);
        ble_scan(); // Restart scanning
        break;

    default:
        break;
    }
    return 0;
}

// 扫描蓝牙设备
static void ble_scan()
{
    struct ble_gap_disc_params params = {0};
    params.itvl = 0x0010;
    params.window = 0x0010;
    params.filter_policy = 0;
    params.limited = 0;
    params.passive = 0;

    int rc = ble_gap_disc(own_addr_type, BLE_HS_FOREVER, &params, ble_gap_event, NULL);
    if (rc != 0)
    {
        printf("Error starting scan; rc=%d\n", rc);
    }
}

// 同步回调函数
void ble_app_on_sync(void)
{
    ble_svc_gap_device_name_set("ESP32_S3_Mouse_Host");
    ble_gap_security_initiate(BLE_ADDR_PUBLIC);
    ble_scan();
}

// NimBLE 端口任务
void nimble_port_task(void *arg)
{
    nimble_port_run();
}

// 启动蓝牙功能
void bt_start()
{
    ble_hs_cfg.sm_io_cap = BLE_HS_IO_NO_INPUT_OUTPUT;
    ble_scan();
}

#endif